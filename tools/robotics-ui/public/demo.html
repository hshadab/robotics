<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Verifiable AI for Robots - Novanet</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap" />
  <style>
    :root {
      --bg: #0a0e14; --panel: #141b24; --panel-light: #1a2332; --accent: #5c7cfa; --accent-glow: rgba(92, 124, 250, 0.2);
      --text: #e5e7eb; --muted: #8b92a0; --ok:#22c55e; --warn:#f59e0b; --err:#ef4444;
      --border: #1d2735; --code-bg: #0f1419;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      line-height: 1.6;
    }

    header {
      padding: 20px 28px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, var(--panel), var(--bg));
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 100;
    }
    .header-content { max-width: 1400px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; }
    .title { font-weight: 700; font-size: 28px; display: flex; align-items: center; gap: 12px; }
    .logo { height: 36px; width: auto; }
    .tagline { color: var(--muted); font-size: 16px; margin-top: 6px; }
    .header-status { display: flex; gap: 12px; align-items: center; }

    main { max-width: 1400px; margin: 0 auto; padding: 24px; }

    .hero-section {
      background: linear-gradient(135deg, var(--panel) 0%, var(--panel-light) 100%);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 32px;
      margin-bottom: 24px;
      position: relative;
      overflow: hidden;
    }
    /* Removed glowing horizontal bar */

    .hero-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 32px; }

    .video-container {
      position: relative;
      background: var(--code-bg);
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid var(--border);
      aspect-ratio: 4/3;
    }
    .video-container img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .video-overlay {
      position: absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .detection-badge {
      background: rgba(20, 27, 36, 0.95);
      backdrop-filter: blur(8px);
      padding: 12px 18px;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-family: 'JetBrains Mono', monospace;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .detection-badge .label { color: var(--ok); font-weight: 700; }
    .detection-badge .conf { color: var(--muted); font-weight: 600; }

    /* FPS counter removed - was distracting during demos */

    .proof-pipeline {
      display: flex;
      flex-direction: row;
      gap: 16px;
      justify-content: space-between;
    }
    .pipeline-step {
      background: var(--code-bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      position: relative;
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      min-height: 140px;
      transition: all 0.4s ease;
    }
    .pipeline-step.active {
      border-color: var(--accent);
      background: linear-gradient(135deg, rgba(92, 124, 250, 0.08) 0%, rgba(92, 124, 250, 0.15) 100%);
      box-shadow: 0 0 30px var(--accent-glow), 0 0 15px rgba(92, 124, 250, 0.3), inset 0 0 40px rgba(92, 124, 250, 0.1);
      animation: cardGlowPulse 2s ease-in-out infinite;
    }
    @keyframes cardGlowPulse {
      0%, 100% {
        box-shadow: 0 0 30px var(--accent-glow), 0 0 15px rgba(92, 124, 250, 0.3), inset 0 0 40px rgba(92, 124, 250, 0.1);
        border-color: var(--accent);
      }
      50% {
        box-shadow: 0 0 45px rgba(92, 124, 250, 0.4), 0 0 25px rgba(92, 124, 250, 0.5), inset 0 0 60px rgba(92, 124, 250, 0.15);
        border-color: #7c9cff;
      }
    }
    .pipeline-step.complete {
      border-color: var(--ok);
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.08) 0%, rgba(34, 197, 94, 0.12) 100%);
      box-shadow: 0 0 10px rgba(34, 197, 94, 0.2);
    }
    .step-header {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
      width: 100%;
    }
    .step-icon {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      background: var(--panel);
      border: 2px solid var(--border);
    }
    .step-icon.active {
      border-color: var(--accent);
      background: var(--accent-glow);
      animation: pulse 2.5s ease-in-out infinite;
    }
    .step-icon.complete { border-color: var(--ok); background: var(--ok); }
    @keyframes pulse {
      0%, 100% {
        box-shadow: 0 0 0 0 var(--accent-glow), 0 0 15px var(--accent);
        transform: scale(1);
      }
      50% {
        box-shadow: 0 0 0 12px transparent, 0 0 25px var(--accent);
        transform: scale(1.05);
      }
    }
    .step-title { font-weight: 600; font-size: 14px; }
    .step-time { color: var(--muted); font-size: 12px; font-family: 'JetBrains Mono', monospace; }
    .step-details { font-size: 12px; color: var(--muted); font-family: 'JetBrains Mono', monospace; }

    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 16px;
      margin-bottom: 24px;
    }
    .metric-card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
    }
    .metric-value {
      font-size: 32px;
      font-weight: 700;
      color: var(--accent);
      font-family: 'JetBrains Mono', monospace;
    }
    .metric-label {
      font-size: 13px;
      color: var(--muted);
      margin-top: 6px;
    }

    .grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 20px; }
    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
    }
    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    h2 {
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .proof-explorer {
      background: var(--code-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      max-height: 400px;
      overflow: auto;
    }
    .proof-hash {
      color: var(--accent);
      word-break: break-all;
      margin: 8px 0;
    }
    .proof-field {
      display: flex;
      gap: 12px;
      margin: 8px 0;
      padding: 8px;
      background: var(--panel);
      border-radius: 6px;
    }
    .proof-field .key { color: var(--ok); min-width: 140px; }
    .proof-field .value { color: var(--text); word-break: break-all; }

    .confidence-bars {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .conf-bar-item {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .conf-label {
      font-size: 13px;
      min-width: 120px;
      font-family: 'JetBrains Mono', monospace;
    }
    .conf-bar-container {
      flex: 1;
      height: 24px;
      background: var(--code-bg);
      border-radius: 4px;
      overflow: hidden;
      position: relative;
    }
    .conf-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--ok));
      transition: width 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 8px;
    }
    .conf-value {
      font-size: 11px;
      font-weight: 600;
      color: white;
      font-family: 'JetBrains Mono', monospace;
    }

    button {
      background: var(--accent);
      color: white;
      border: none;
      padding: 10px 18px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      transition: all 0.2s;
    }
    button:hover { transform: translateY(-1px); box-shadow: 0 4px 12px var(--accent-glow); }
    button.secondary { background: var(--panel-light); }
    button.ok {
      background: linear-gradient(135deg, #0f5132 0%, #0a3622 100%);
      opacity: 0.5;
      position: relative;
    }
    button.ok:hover {
      background: linear-gradient(135deg, #166534 0%, #14532d 100%);
      opacity: 0.7;
      transform: translateY(-1px);
    }
    button.ok.active {
      background: linear-gradient(135deg, #22c55e 0%, #4ade80 100%);
      opacity: 1;
      border: 4px solid #22c55e;
      box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.3);
    }
    button.ok.active:hover {
      background: linear-gradient(135deg, #16a34a 0%, #22c55e 100%);
      box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.5), 0 6px 16px rgba(34, 197, 94, 0.4);
      transform: translateY(-2px);
    }
    button.danger {
      background: linear-gradient(135deg, #7f1d1d 0%, #5c1010 100%);
      opacity: 0.5;
      position: relative;
    }
    button.danger:hover {
      background: linear-gradient(135deg, #991b1b 0%, #7f1d1d 100%);
      opacity: 0.7;
      transform: translateY(-1px);
    }
    button.danger.active {
      background: linear-gradient(135deg, #ef4444 0%, #f87171 100%);
      opacity: 1;
      border: 4px solid #ef4444;
      box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.3);
    }
    button.danger.active:hover {
      background: linear-gradient(135deg, #dc2626 0%, #ef4444 100%);
      box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.5), 0 6px 16px rgba(239, 68, 68, 0.4);
      transform: translateY(-2px);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 4px 12px;
      font-size: 12px;
      color: var(--muted);
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--muted);
    }
    .status-dot.on { background: var(--ok); animation: glow 2s infinite; }
    @keyframes glow {
      0%, 100% { box-shadow: 0 0 4px var(--ok); }
      50% { box-shadow: 0 0 12px var(--ok); }
    }

    .event-log {
      background: var(--code-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      max-height: 300px;
      overflow-y: auto;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      line-height: 1.6;
    }
    .event-line {
      padding: 4px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .event-line:last-child { border-bottom: none; }
    .event-ts { color: var(--muted); }
    .event-proof-ok { color: var(--ok); }
    .event-proof-fail { color: var(--warn); }
    .proof-snapshot {
      width: 60px;
      height: 45px;
      border-radius: 4px;
      border: 1px solid var(--border);
      object-fit: cover;
      flex-shrink: 0;
    }
    .event-content {
      flex: 1;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
    }

    .controls-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }

    .motion-badge {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 8px 16px;
      border-radius: 8px;
      border: 2px solid var(--border);
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    .motion-badge-icon {
      font-size: 18px;
    }
    .motion-badge-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .motion-badge-status {
      font-size: 16px;
      line-height: 1;
      font-weight: 700;
    }
    .motion-badge-details {
      font-size: 16px;
      font-weight: 700;
      opacity: 1;
      line-height: 1.3;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <div>
        <div class="title">
          <img src="https://cdn.prod.website-files.com/65d52b07d5bc41614daa723f/665df12739c532f45b665fe7_logo-novanet.svg" alt="Novanet" class="logo" />
          Verifiable AI for Robots
        </div>
        <div class="tagline">Real-time cryptographic proofs for ML inference</div>
      </div>
      <div class="header-status">
        <div class="pill">
          <span class="status-dot" id="proxyStatus"></span>
          <span id="proxyText">Connecting...</span>
        </div>
      </div>
    </div>
  </header>

  <main>
    <!-- Controls -->
    <div class="card" style="margin-bottom: 20px;">
      <div class="card-header">
        <h2>üéÆ System Controls</h2>
        <div class="motion-badge" id="motionBadge">
          <div class="motion-badge-icon" id="motionBadgeIcon">‚è∏</div>
          <div class="motion-badge-text">
            <div class="motion-badge-status" id="motionBadgeStatus">MOTION IDLE</div>
            <div class="motion-badge-details" id="motionBadgeDetails">No active proof</div>
          </div>
        </div>
      </div>
      <div class="controls-row">
        <button id="btnStartFull" class="ok">‚ñ∂ Start Full Demo</button>
        <button id="btnStopAll" class="danger active">‚èπ Stop All</button>
        <label style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
          <input type="checkbox" id="chkProofOn" checked />
          Enable Proofs
        </label>
        <label style="display: flex; align-items: center; gap: 8px; font-size: 14px;">
          Mode:
          <select id="selMode" style="padding: 6px 12px; border-radius: 6px; border: 1px solid var(--border); background: var(--panel); color: var(--text);">
            <option value="http">HTTP Verifier</option>
            <option value="cli">CLI Verifier</option>
          </select>
        </label>
        <button id="btnFlipModel" class="danger" style="font-size: 14px;">
          ‚ö†Ô∏è Flip to Tampered Model
        </button>
      </div>
      <div class="controls-row">
        <div class="pill"><span class="status-dot" id="sVerifier"></span> Verifier</div>
        <div class="pill"><span class="status-dot" id="sCamera"></span> Camera</div>
        <div class="pill"><span class="status-dot" id="sGuard"></span> Guard</div>
        <div class="pill"><span class="status-dot" id="sTeleop"></span> Teleop</div>
        <div class="pill" id="winCamPill"><span class="status-dot" id="sWinCam"></span> <span id="winCamText">Win Camera</span></div>
        <button id="btnWinCamHelp" class="secondary" style="font-size: 12px; padding: 6px 12px;">üì∑ Camera Help</button>
      </div>
    </div>

    <!-- Tampered Model Alert Banner (hidden by default) -->
    <div id="tamperedModelBanner" class="card" style="margin-bottom: 20px; display: none; border-left: 4px solid var(--err); background: rgba(239, 68, 68, 0.1);">
      <div style="display: flex; align-items: center; gap: 16px; padding: 8px;">
        <span style="font-size: 36px;">‚ö†Ô∏è</span>
        <div style="flex: 1;">
          <div style="font-weight: 700; font-size: 18px; color: var(--err); margin-bottom: 4px;">MODEL HASH MISMATCH DETECTED</div>
          <div style="font-size: 14px; color: var(--text); font-family: 'JetBrains Mono', monospace;">
            Expected: c0c3f76d... ‚Üí Actual: b8e4a92c... | NEXT proof will FAIL | Motion will be BLOCKED
          </div>
        </div>
        <button id="btnRestoreModel" class="ok" style="font-size: 14px;">
          ‚úì Restore Original Model
        </button>
      </div>
    </div>

    <!-- Windows Camera Instructions (hidden by default) -->
    <div id="winCamInstructions" class="card" style="margin-bottom: 20px; display: none; border-left: 4px solid var(--warn);">
      <div class="card-header">
        <h2>üì∑ Start Windows Camera</h2>
        <button id="btnCloseInstructions" class="secondary" style="font-size: 12px; padding: 4px 10px;">‚úï</button>
      </div>
      <div style="color: var(--muted); margin-bottom: 12px;">
        The Windows camera HTTP server is not running. Follow these steps to start it:
      </div>
      <div style="background: var(--code-bg); border-radius: 8px; padding: 16px; font-family: 'JetBrains Mono', monospace; font-size: 13px; margin-bottom: 12px;">
        <div style="color: var(--ok); margin-bottom: 8px;">Step 1: Open PowerShell on Windows</div>
        <div style="color: var(--muted); margin-bottom: 12px;">Press <kbd style="background: var(--panel); padding: 2px 6px; border-radius: 4px;">Win + X</kbd>, then select "Windows PowerShell"</div>

        <div style="color: var(--ok); margin-bottom: 8px;">Step 2: Navigate to robotics directory</div>
        <div style="background: var(--panel); padding: 8px; border-radius: 4px; margin-bottom: 4px;">
          cd \\wsl$\Ubuntu\home\hshadab\robotics
        </div>
        <button id="btnCopyPath" class="secondary" style="font-size: 11px; padding: 4px 8px; margin-bottom: 12px;">üìã Copy Path</button>

        <div style="color: var(--ok); margin-bottom: 8px;">Step 3: Run the camera script with ID 1</div>
        <div style="background: var(--panel); padding: 8px; border-radius: 4px; margin-bottom: 4px;">
          python simple_windows_camera.py 1
        </div>
        <button id="btnCopyCmd" class="secondary" style="font-size: 11px; padding: 4px 8px; margin-bottom: 12px;">üìã Copy Command</button>

        <div style="color: var(--ok); margin-bottom: 8px;">‚úì Your webcam light should turn ON</div>
        <div style="color: var(--muted);">Keep the PowerShell window open while using the demo</div>
      </div>
      <div style="display: flex; gap: 12px;">
        <button id="btnRefreshCam" class="ok" style="font-size: 13px;">üîÑ Check Camera Status</button>
        <button id="btnTestWithPattern" class="secondary" style="font-size: 13px;">üé® Use Test Pattern Instead</button>
      </div>
    </div>

    <!-- Hero Section: Camera + Verified Proofs -->
    <div class="hero-section">
      <div class="hero-grid">
        <!-- Live Camera Feed -->
        <div>
          <h2 style="margin-bottom: 16px;">üìπ Live Camera Feed</h2>
          <div class="video-container">
            <img id="cameraFeed" src="/api/frame.png" alt="Camera feed" />
            <div class="video-overlay">
              <div class="detection-badge">
                <span class="label" id="detectionLabel">‚Äî</span>
                <span class="conf" id="detectionConf">‚Äî</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Verified Proofs -->
        <div>
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
            <h2>‚úì Verified Proofs</h2>
            <button id="btnClearProofs" class="secondary" style="font-size: 12px; padding: 6px 12px;">Clear</button>
          </div>
          <div class="event-log" id="verifiedProofsList" style="max-height: 450px;">
            <div style="color: var(--muted); text-align: center; padding: 20px;">No verified proofs yet</div>
          </div>
        </div>
      </div>
    </div>

    <!-- ZK Proof Pipeline (horizontal) -->
    <div style="margin-bottom: 24px;">
      <h2 style="margin-bottom: 16px;">‚ö° ZK Proof Pipeline</h2>
      <div class="proof-pipeline">
        <div class="pipeline-step" id="step1">
          <div class="step-header">
            <div class="step-icon">üîç</div>
            <div>
              <div class="step-title">ML Inference</div>
              <div class="step-time" id="step1Time">‚Äî</div>
            </div>
          </div>
          <div class="step-details" id="step1Details">Waiting for image...</div>
        </div>

        <div class="pipeline-step" id="step2">
          <div class="step-header">
            <div class="step-icon">üîê</div>
            <div>
              <div class="step-title">Proof Generation</div>
              <div class="step-time" id="step2Time">‚Äî</div>
            </div>
          </div>
          <div class="step-details" id="step2Details">Waiting...</div>
        </div>

        <div class="pipeline-step" id="step3">
          <div class="step-header">
            <div class="step-icon">‚úì</div>
            <div>
              <div class="step-title">Verification</div>
              <div class="step-time" id="step3Time">‚Äî</div>
            </div>
          </div>
          <div class="step-details" id="step3Details">Waiting...</div>
        </div>
      </div>
    </div>

    <!-- Latest Proof - Full Width with 2x4 Grid -->
    <div class="card" style="margin-bottom: 20px;">
      <div class="card-header">
        <h2>üîê Latest Proof</h2>
        <button id="btnDownloadProof" class="secondary" style="font-size: 12px; padding: 6px 12px;">Download JSON</button>
      </div>
      <div id="proofExplorer" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px;">
        <div style="color: var(--muted); text-align: center; padding: 20px; grid-column: 1 / -1;">No proof generated yet</div>
      </div>
    </div>

  </main>

  <script>
    console.log('‚úÖ JavaScript loaded and executing');

    // State
    let frameCount = 0;
    let proofCount = 0;
    let successCount = 0;
    let proofTimes = [];
    let lastEvent = null;
    let lastFrameTime = Date.now();

    // Initialize seenProofIds to track which proofs we've already counted
    window.seenProofIds = new Set();

    // Helpers
    const q = id => document.getElementById(id);
    const api = (p, opts={}) => fetch(p, { headers: {'Content-Type': 'application/json'}, ...opts });

    console.log('‚úÖ Helper functions defined');

    // Update metrics (no-op since metrics section was removed from UI)
    function updateMetrics() {
      // Metrics section was removed from the UI
      // Keeping function for compatibility but no DOM updates needed
    }

    // Update camera feed
    function updateCamera() {
      const now = Date.now();

      q('cameraFeed').src = `/api/frame.png?ts=${now}`;
      frameCount++;
    }

    // Reset all status lights to off state
    function resetStatusLights() {
      // Turn off process status lights
      ['Verifier', 'Camera', 'Guard', 'Teleop'].forEach(name => {
        const dot = q(`s${name}`);
        dot.className = 'status-dot';  // Remove 'on' class
      });
    }

    // Reset entire UI to stopped/idle state
    function resetUIToStopped() {
      // Clear last event
      lastEvent = null;

      // Reset pipeline to idle
      resetPipelineToIdle();

      // Clear detection display
      q('detectionLabel').textContent = '‚Äî';
      q('detectionConf').textContent = '‚Äî';

      // Reset motion badge to idle
      const badge = q('motionBadge');
      const badgeIcon = q('motionBadgeIcon');
      const badgeStatus = q('motionBadgeStatus');
      const badgeDetails = q('motionBadgeDetails');

      badge.style.borderColor = 'var(--border)';
      badge.style.backgroundColor = 'transparent';
      badgeIcon.textContent = '‚è∏';
      badgeIcon.style.color = 'var(--muted)';
      badgeStatus.textContent = 'MOTION IDLE';
      badgeStatus.style.color = 'var(--muted)';
      badgeDetails.textContent = '';  // No details for idle state
      badgeDetails.style.color = 'var(--muted)';

      // Turn off all status lights
      resetStatusLights();
    }

    // Reset pipeline to idle state (when services stopped)
    function resetPipelineToIdle() {
      // Step 1: Idle
      q('step1').className = 'pipeline-step';
      q('step1').querySelector('.step-icon').className = 'step-icon';
      q('step1').querySelector('.step-icon').textContent = '‚è∏';
      q('step1Time').textContent = 'Idle';
      q('step1Details').textContent = 'Waiting for guard to start...';

      // Step 2: Idle
      q('step2').className = 'pipeline-step';
      q('step2').querySelector('.step-icon').className = 'step-icon';
      q('step2').querySelector('.step-icon').textContent = '‚è∏';
      q('step2Time').textContent = 'Idle';
      q('step2Details').textContent = 'Waiting...';

      // Step 3: Idle
      q('step3').className = 'pipeline-step';
      q('step3').querySelector('.step-icon').className = 'step-icon';
      q('step3').querySelector('.step-icon').textContent = '‚è∏';
      q('step3Time').textContent = 'Idle';
      q('step3Details').textContent = 'Waiting...';
    }

    // Update proof pipeline visualization
    function updatePipeline(event, guardRunning = false) {
      if (!event) {
        // No event - show all steps as idle
        resetPipelineToIdle();
        return;
      }

      // Step 1: Inference - only show as complete if guard is actually running and processing
      if (guardRunning && event.ts) {
        q('step1').className = 'pipeline-step complete';
        q('step1').querySelector('.step-icon').className = 'step-icon complete';
        q('step1').querySelector('.step-icon').textContent = '‚úì';
        q('step1Time').textContent = 'Complete';
        q('step1Details').textContent = `Model: ${event.model_path?.split('/').pop() || 'Unknown'}`;
      } else {
        // Guard stopped or no active inference
        q('step1').className = 'pipeline-step';
        q('step1').querySelector('.step-icon').className = 'step-icon';
        q('step1').querySelector('.step-icon').textContent = '‚è∏';
        q('step1Time').textContent = 'Idle';
        q('step1Details').textContent = 'Waiting for guard to start...';
      }

      // Step 2: Proof Generation - only active if guard is running AND threshold met
      if (guardRunning && event.proof_ms) {
        // Proof completed
        q('step2').className = 'pipeline-step complete';
        q('step2').querySelector('.step-icon').className = 'step-icon complete';
        q('step2').querySelector('.step-icon').textContent = '‚úì';
        q('step2Time').textContent = `${event.proof_ms}ms`;
        q('step2Details').textContent = `Proof ID: ${event.proof_id?.substring(0, 16) || 'N/A'}...`;
      } else if (guardRunning && event.predicate_met) {
        // Proof generation in progress
        q('step2').className = 'pipeline-step active';
        q('step2').querySelector('.step-icon').className = 'step-icon active';
        q('step2').querySelector('.step-icon').textContent = 'üîê';
        q('step2Time').textContent = 'Generating...';
        q('step2Details').textContent = 'Creating cryptographic proof (this takes ~4-13s)';
      } else if (guardRunning) {
        // Guard running but waiting for threshold
        q('step2').className = 'pipeline-step';
        q('step2').querySelector('.step-icon').className = 'step-icon';
        q('step2').querySelector('.step-icon').textContent = '‚è∏';
        q('step2Time').textContent = 'Ready';
        q('step2Details').textContent = 'Waiting for confidence threshold';
      } else {
        // Guard stopped - idle state
        q('step2').className = 'pipeline-step';
        q('step2').querySelector('.step-icon').className = 'step-icon';
        q('step2').querySelector('.step-icon').textContent = '‚è∏';
        q('step2Time').textContent = 'Idle';
        q('step2Details').textContent = 'Waiting...';
      }

      // Step 3: Verification - only show states if guard is running
      // Keep showing "Verified" state as long as motion is unlocked (within 10 second window)
      const now = Date.now() / 1000;
      const verifiedUntil = event.verified_until || 0;
      const stillUnlocked = verifiedUntil > now;

      if (guardRunning && event.proof_verified === true && stillUnlocked) {
        // Show verified state for the full 10-second unlock duration
        const timeLeft = Math.ceil(verifiedUntil - now);
        q('step3').className = 'pipeline-step complete';
        q('step3').querySelector('.step-icon').className = 'step-icon complete';
        q('step3').querySelector('.step-icon').textContent = '‚úì';
        q('step3Time').textContent = `Verified (${timeLeft}s)`;
        q('step3Details').textContent = '‚úì Proof cryptographically valid';

        // Only increment successCount once per proof
        if (event.proof_id && !window.seenProofIds.has(event.proof_id)) {
          successCount++;
        }
      } else if (guardRunning && event.proof_verified === false && event.proof_id) {
        // Only show "Failed" if there was actually a proof attempt (has proof_id)
        q('step3').className = 'pipeline-step';
        q('step3').querySelector('.step-icon').textContent = '‚úó';
        q('step3Time').textContent = 'Failed';
        q('step3Details').textContent = 'Proof verification failed';
      } else if (guardRunning) {
        // Guard running but no proof yet
        q('step3').className = 'pipeline-step';
        q('step3').querySelector('.step-icon').className = 'step-icon';
        q('step3').querySelector('.step-icon').textContent = '‚è∏';
        q('step3Time').textContent = 'Ready';
        q('step3Details').textContent = 'Awaiting proof generation';
      } else {
        // Guard stopped - idle state
        q('step3').className = 'pipeline-step';
        q('step3').querySelector('.step-icon').className = 'step-icon';
        q('step3').querySelector('.step-icon').textContent = '‚è∏';
        q('step3Time').textContent = 'Idle';
        q('step3Details').textContent = 'Waiting...';
      }

      // Count proofs: increment when we have a verified or failed proof status
      if (event.proof_verified === true || event.proof_verified === false) {
        // Only count this proof once by checking if we've seen this proof_id before
        if (event.proof_id && !window.seenProofIds) {
          window.seenProofIds = new Set();
        }
        if (event.proof_id && !window.seenProofIds.has(event.proof_id)) {
          window.seenProofIds.add(event.proof_id);
          proofCount++;
          if (event.proof_ms) {
            proofTimes.push(event.proof_ms);
            if (proofTimes.length > 20) proofTimes.shift();
          }
        }
      }
    }

    // Update detection display
    function updateDetection(event, guardRunning = false) {
      // Clear when guard is not running (demo stopped)
      if (!guardRunning || !event) {
        q('detectionLabel').textContent = '‚Äî';
        q('detectionConf').textContent = '‚Äî';
        return;
      }

      // ALWAYS show live detection when guard is running and we have valid inference results
      // The guard publishes fresh detection data every 500ms
      if (event.top1_label && event.top1_score) {
        q('detectionLabel').textContent = event.top1_label;
        q('detectionConf').textContent = `${(event.top1_score * 100).toFixed(1)}%`;
      } else {
        // No valid detection data available yet
        q('detectionLabel').textContent = '‚Äî';
        q('detectionConf').textContent = '‚Äî';
      }
    }

    // Update confidence bars (mock top-5 for now)
    function updateConfidenceBars(event) {
      if (!event || !event.top1_score) return;

      // Generate mock top-5 (in real version, get from logits)
      const bars = [
        { label: event.top1_label || 'Unknown', conf: event.top1_score },
        { label: 'Other class 1', conf: event.top1_score * 0.4 },
        { label: 'Other class 2', conf: event.top1_score * 0.2 },
        { label: 'Other class 3', conf: event.top1_score * 0.1 },
        { label: 'Other class 4', conf: event.top1_score * 0.05 },
      ];

      q('confidenceBars').innerHTML = bars.map(b => `
        <div class="conf-bar-item">
          <div class="conf-label">${b.label}</div>
          <div class="conf-bar-container">
            <div class="conf-bar-fill" style="width: ${b.conf * 100}%">
              <span class="conf-value">${(b.conf * 100).toFixed(1)}%</span>
            </div>
          </div>
        </div>
      `).join('');
    }

    // Update proof explorer (2x4 grid layout)
    function updateProofExplorer(event) {
      if (!event) return;

      const fields = [
        { key: 'Top Prediction', value: event.top1_label ? `${event.top1_label}` : 'N/A' },
        { key: 'Confidence', value: event.top1_score ? `${(event.top1_score * 100).toFixed(2)}%` : 'N/A' },
        { key: 'Proof Verified', value: event.proof_verified ? '‚úì TRUE' : '‚úó FALSE' },
        { key: 'Proof Time', value: event.proof_ms ? `${event.proof_ms}ms` : 'N/A' },
        { key: 'Model Hash', value: event.model_sha256 ? `${event.model_sha256.substring(0, 16)}...` : 'N/A' },
        { key: 'Input Hash', value: event.input_sha256 ? `${event.input_sha256.substring(0, 16)}...` : 'N/A' },
        { key: 'Proof ID', value: event.proof_id ? `${event.proof_id.substring(0, 16)}...` : 'N/A' },
        { key: 'Timestamp', value: event.ts ? new Date(event.ts * 1000).toLocaleTimeString() : 'N/A' },
      ];

      q('proofExplorer').innerHTML = fields.map(f => `
        <div style="background: var(--code-bg); border: 1px solid var(--border); border-radius: 8px; padding: 16px; text-align: center;">
          <div style="font-size: 11px; color: var(--muted); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">${f.key}</div>
          <div style="font-size: 14px; font-weight: 600; color: var(--text); font-family: 'JetBrains Mono', monospace; word-break: break-all;">${f.value || 'N/A'}</div>
        </div>
      `).join('');
    }

    // Update motion gating status
    function updateMotionGating(event) {
      if (!event) return;

      // Badge elements
      const badge = q('motionBadge');
      const badgeIcon = q('motionBadgeIcon');
      const badgeStatus = q('motionBadgeStatus');
      const badgeDetails = q('motionBadgeDetails');

      const now = Date.now() / 1000; // Current time in seconds
      const verifiedUntil = event.verified_until || 0;
      const timeRemaining = verifiedUntil - now;

      // Only show MOTION ALLOWED if:
      // 1. We have a verified proof (proof_verified === true)
      // 2. AND the countdown hasn't expired (timeRemaining > 0)
      const hasActiveProof = event.proof_verified === true && timeRemaining > 0;

      if (hasActiveProof) {
        // MOTION ALLOWED - valid proof exists and is still within unlock window
        const seconds = Math.ceil(timeRemaining);

        // Update badge
        badge.style.borderColor = 'var(--ok)';
        badge.style.backgroundColor = 'rgba(34, 197, 94, 0.1)';
        badgeIcon.textContent = '';  // No icon
        badgeIcon.style.color = 'var(--ok)';
        badgeStatus.textContent = `MOTION ALLOWED ${seconds}s`;
        badgeStatus.style.color = 'var(--ok)';
        badgeDetails.textContent = '';  // No details
        badgeDetails.style.color = 'var(--ok)';
      } else {
        // MOTION BLOCKED - no valid proof or expired
        // Update badge
        badge.style.borderColor = 'var(--err)';
        badge.style.backgroundColor = 'rgba(239, 68, 68, 0.1)';
        badgeIcon.textContent = '';  // No icon
        badgeIcon.style.color = 'var(--err)';
        badgeStatus.textContent = 'MOTION BLOCKED';
        badgeStatus.style.color = 'var(--err)';
        badgeDetails.textContent = '';  // No details
        badgeDetails.style.color = 'var(--err)';
      }
    }

    // Update verified proofs list from API
    async function updateVerifiedProofsList() {
      try {
        const r = await api('/api/verified_proofs');
        const proofs = await r.json();

        const list = q('verifiedProofsList');

        if (!proofs || proofs.length === 0) {
          list.innerHTML = '<div style="color: var(--muted); text-align: center; padding: 20px;">No verified proofs yet</div>';
          return;
        }

        // Build HTML for all proofs
        const html = proofs.map(event => {
          const ts = new Date(event.ts * 1000).toLocaleString();
          const shortProofId = event.proof_id ? event.proof_id.substring(0, 12) + '...' : 'N/A';
          const proofTime = event.proof_ms ? ` (${event.proof_ms}ms)` : '';

          // Include snapshot thumbnail if available
          const snapshotHtml = event.snapshot ?
            `<img src="/api/snapshot/${event.snapshot}.png" class="proof-snapshot" alt="Snapshot" />` :
            '';

          return `
            <div class="event-line">
              ${snapshotHtml}
              <div class="event-content">
                <span class="event-ts">[${ts}]</span>
                <span class="event-proof-ok">‚úì ${event.top1_label || 'Unknown'}</span>
                <span style="color: var(--muted);">${(event.top1_score * 100).toFixed(1)}%${proofTime}</span>
                <span style="color: var(--accent); font-size: 10px;">ID: ${shortProofId}</span>
              </div>
            </div>
          `;
        }).join('');

        list.innerHTML = html;
      } catch (e) {
        console.error('Failed to load verified proofs:', e);
      }
    }

    // Check Windows camera status
    async function checkWindowsCamera() {
      try {
        const r = await api('/api/windows_camera_status');
        const result = await r.json();
        const dot = q('sWinCam');
        const text = q('winCamText');
        const pill = q('winCamPill');

        if (result.running) {
          dot.className = 'status-dot on';
          text.textContent = 'Win Camera ON';
          pill.style.borderColor = 'var(--ok)';
        } else {
          dot.className = 'status-dot';
          text.textContent = 'Win Camera OFF';
          pill.style.borderColor = 'var(--warn)';
        }

        return result.running;
      } catch (e) {
        console.error('Camera check failed:', e);
        return false;
      }
    }

    // Main update function
    async function update() {
      try {
        // FIRST: Check if guard is running BEFORE processing events
        const status = await (await api('/status')).json();
        const guardRunning = status.guard || false;

        // Update status dots (even when guard is stopped)
        ['Verifier', 'Camera', 'Guard', 'Teleop'].forEach(name => {
          const dot = q(`s${name}`);
          const on = status[name.toLowerCase()];
          dot.className = on ? 'status-dot on' : 'status-dot';
        });

        // If guard is not running, reset pipeline to idle state
        if (!guardRunning) {
          if (lastEvent) {
            lastEvent = null;
          }
          updatePipeline(null, false);
          updateDetection(null, false);

          // Update proxy status and Windows camera even when stopped
          const proxy = await (await api('/api/proxy_status')).json();
          const allRunning = proxy.event_proxy?.running && proxy.frame_proxy?.running;
          q('proxyStatus').className = allRunning ? 'status-dot on' : 'status-dot';
          q('proxyText').textContent = allRunning ? 'Proxies Online' : 'Proxies Offline';

          checkWindowsCamera().catch(e => console.error('Camera check failed:', e));

          // Don't process any events if guard is stopped
          return;
        }

        const r = await api('/api/last_event');
        if (r.status === 200) {
          let event = await r.json();

          // Check if the unlock window has expired - if so, clear stale proof state
          const now = Date.now() / 1000;
          const verifiedUntil = event.verified_until || 0;
          const unlockExpired = verifiedUntil > 0 && verifiedUntil < now;

          if (unlockExpired) {
            // Countdown expired - clear proof state to reset for next cycle
            // Keep detection data (top1_label, top1_score) but clear proof metadata
            event = {
              ts: event.ts,
              top1_label: event.top1_label,
              top1_score: event.top1_score,
              model_path: event.model_path,
              // Clear all proof-related fields
              proof_verified: undefined,
              proof_id: undefined,
              proof_ms: undefined,
              verified_until: undefined,
              predicate_met: undefined,
              input_sha256: undefined,
              model_sha256: undefined
            };
          }

          // Fetch verified proofs to merge with live event (only if unlock hasn't expired)
          if (!unlockExpired) {
            const proofsResp = await api('/api/verified_proofs');
            const verifiedProofs = await proofsResp.json();

            // If we have a verified proof that matches the current verified_until window, merge it
            if (verifiedProofs && verifiedProofs.length > 0 && event.verified_until) {
              const mostRecentProof = verifiedProofs[0]; // Most recent verified proof
              // Check if this verified proof is for the current unlock window
              if (mostRecentProof.verified_until === event.verified_until && mostRecentProof.proof_verified === true) {
                // Merge verified proof data into the event
                event = {...event, ...mostRecentProof};
              }
            }
          }

          // Check if proof_verified status changed from false to true
          const proofJustVerified = event.proof_verified === true && lastEvent?.proof_verified === false;

          // Also check if we have a newly verified proof by comparing proof_ids
          const hasNewProof = event.proof_id && event.proof_verified === true &&
                              event.proof_id !== lastEvent?.proof_id;

          // Always update if event changed OR if guard just started (lastEvent was null)
          const shouldUpdateFull = !lastEvent ||
                                   event.ts !== lastEvent?.ts ||
                                   event.proof_verified !== lastEvent?.proof_verified ||
                                   event.proof_id !== lastEvent?.proof_id;

          if (shouldUpdateFull) {
            lastEvent = event;
            updatePipeline(event, guardRunning);
            updateDetection(event, guardRunning);
            updateProofExplorer(event);
            updateMotionGating(event);
            updateMetrics();

            // If proof just got verified OR we have a new proof, immediately update the proofs list
            if (proofJustVerified || hasNewProof) {
              await updateVerifiedProofsList();
              window.lastProofListUpdate = Date.now();
            }
          } else {
            // Still update motion gating, pipeline, and detection even if event hasn't changed (for countdown)
            updateMotionGating(event);
            updatePipeline(event, guardRunning);
            updateDetection(event, guardRunning);
          }
        }

        // Update verified proofs list from API (periodic check every 5 seconds)
        // Skip if we just updated it above for a newly verified proof
        const timeSinceLastUpdate = Date.now() - (window.lastProofListUpdate || 0);
        if (timeSinceLastUpdate > 5000) {
          await updateVerifiedProofsList();
          window.lastProofListUpdate = Date.now();
        }

        // Status dots already updated at the top of this function (lines 1155-1160)

        // Proxy status
        const proxy = await (await api('/api/proxy_status')).json();
        const allRunning = proxy.event_proxy?.running && proxy.frame_proxy?.running;
        q('proxyStatus').className = allRunning ? 'status-dot on' : 'status-dot';
        q('proxyText').textContent = allRunning ? 'Proxies Online' : 'Proxies Offline';

        // Check Windows camera (non-blocking - don't let it stop the update loop)
        checkWindowsCamera().catch(e => console.error('Camera check failed:', e));

      } catch (e) {
        console.error('Update failed:', e);
      }
    }


    // Initialize: Attach all button handlers after DOM is loaded
    async function initializePage() {
      console.log('Page loaded: Attaching button handlers...');

      // Immediately set initial state to stopped/idle
      console.log('Setting initial UI state to stopped...');
      resetUIToStopped();

      // Controls
      q('btnStartFull').onclick = async () => {
        console.log('Start button clicked!');
        const mode = q('selMode').value;
        const proofOn = q('chkProofOn').checked;
        // burger=0 uses real camera, burger=1 uses test pattern

        // Toggle button states
        q('btnStartFull').classList.add('active');
        q('btnStopAll').classList.remove('active');

        console.log('Calling /start/full API...');
        try {
          const result = await api(`/start/full?mode=${mode}&burger=0&record=0`);
          console.log('Start result:', await result.json());
        } catch (e) {
          console.error('Start failed:', e);
        }
      };

      q('btnStopAll').onclick = async () => {
        console.log('Stop button clicked!');

        // Toggle button states
        q('btnStopAll').classList.add('active');
        q('btnStartFull').classList.remove('active');

        // Immediately reset UI to stopped state (don't wait for API or update loop)
        resetUIToStopped();

        // Call API to stop all services
        try {
          await api('/stop/all');
          console.log('All services stopped');
        } catch (e) {
          console.error('Stop failed:', e);
        }
      };

      q('btnDownloadProof').onclick = () => {
        if (!lastEvent) return;
        const blob = new Blob([JSON.stringify(lastEvent, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `proof-${Date.now()}.json`;
        a.click();
      };

      q('btnClearProofs').onclick = async () => {
        try {
          await api('/api/clear_verified_proofs', { method: 'POST' });
          const list = q('verifiedProofsList');
          list.innerHTML = '<div style="color: var(--muted); text-align: center; padding: 20px;">No verified proofs yet</div>';
        } catch (e) {
          console.error('Failed to clear verified proofs:', e);
        }
      };

      // Windows camera help button
      q('btnWinCamHelp').onclick = async () => {
        const running = await checkWindowsCamera();
        const instructions = q('winCamInstructions');

        if (running) {
          alert('‚úì Windows camera is already running!\n\nYour webcam should be active and serving frames.');
        } else {
          instructions.style.display = 'block';
          instructions.scrollIntoView({ behavior: 'smooth' });
        }
      };

      // Close instructions
      q('btnCloseInstructions').onclick = () => {
        q('winCamInstructions').style.display = 'none';
      };

      // Copy buttons
      q('btnCopyPath').onclick = () => {
        navigator.clipboard.writeText('cd \\\\wsl$\\Ubuntu\\home\\hshadab\\robotics');
        q('btnCopyPath').textContent = '‚úì Copied!';
        setTimeout(() => q('btnCopyPath').textContent = 'üìã Copy Path', 2000);
      };

      q('btnCopyCmd').onclick = () => {
        navigator.clipboard.writeText('python simple_windows_camera.py 1');
        q('btnCopyCmd').textContent = '‚úì Copied!';
        setTimeout(() => q('btnCopyCmd').textContent = 'üìã Copy Command', 2000);
      };

      // Refresh camera status
      q('btnRefreshCam').onclick = async () => {
        const running = await checkWindowsCamera();
        if (running) {
          alert('‚úì Camera detected!\n\nThe Windows camera HTTP server is now running.');
          q('winCamInstructions').style.display = 'none';
        } else {
          alert('‚úó Camera not detected\n\nMake sure you\'ve started the camera script in PowerShell.');
        }
      };

      // Use test pattern instead
      q('btnTestWithPattern').onclick = async () => {
        if (confirm('Switch to test pattern mode?\n\nThis will use an animated test pattern instead of your camera.')) {
          await api('/stop/all');
          await api('/start/full?mode=http&burger=1&record=0');
          q('winCamInstructions').style.display = 'none';
          alert('‚úì Started with test pattern\n\nYou should see the animated burger pattern in the camera feed.');
        }
      };

      // Tampered Model Demo handler
      q('btnFlipModel').onclick = async () => {
        console.log('Flip to Tampered Model button clicked!');

        try {
          // Call backend API to swap model
          const result = await api('/api/flip_model', { method: 'POST' });
          const data = await result.json();

          if (!data.ok) {
            alert(`‚ö†Ô∏è Model swap failed: ${data.error}`);
            return;
          }

          console.log('Model swapped:', data);

          // Update banner with actual hash values
          const banner = q('tamperedModelBanner');
          const bannerText = banner.querySelector('div[style*="font-family: \'JetBrains Mono\'"]');
          if (bannerText && data.originalHash && data.tamperedHash) {
            bannerText.textContent = `Expected: ${data.originalHash}... ‚Üí Actual: ${data.tamperedHash}... | NEXT proof will FAIL | Motion will be BLOCKED`;
          }

          // Show the tampered model banner (but don't scroll - let user see current state)
          banner.style.display = 'block';

          // Update button text
          q('btnFlipModel').textContent = '‚úì Tampered Model Active';
          q('btnFlipModel').disabled = true;

          // IMPORTANT: Restart the guard to reload the tampered model from disk
          // The guard loads the model into memory at startup, so we need to restart it
          console.log('Restarting guard to load tampered model...');
          await api('/stop/guard', { method: 'POST' });
          await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for clean shutdown
          const mode = q('selMode').value;
          await api('/start/guard', {
            method: 'POST',
            body: JSON.stringify({ mode: mode })
          });
          console.log('Guard restarted with tampered model');
        } catch (e) {
          console.error('Failed to flip model:', e);
          alert(`‚ö†Ô∏è Model swap failed: ${e.message}`);
        }
      };

      // Restore Model handler
      q('btnRestoreModel').onclick = async () => {
        console.log('Restore Original Model button clicked!');

        try {
          // Call backend API to restore model
          const result = await api('/api/restore_model', { method: 'POST' });
          const data = await result.json();

          if (!data.ok) {
            alert(`‚ö†Ô∏è Model restore failed: ${data.error}`);
            return;
          }

          console.log('Model restored:', data);

          // Hide the tampered model banner
          q('tamperedModelBanner').style.display = 'none';

          // Reset button
          q('btnFlipModel').textContent = '‚ö†Ô∏è Flip to Tampered Model';
          q('btnFlipModel').disabled = false;

          // Restart the guard to reload the original model from disk
          console.log('Restarting guard to load original model...');
          await api('/stop/guard', { method: 'POST' });
          await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for clean shutdown
          const mode = q('selMode').value;
          await api('/start/guard', {
            method: 'POST',
            body: JSON.stringify({ mode: mode })
          });
          console.log('Guard restarted with original model');
        } catch (e) {
          console.error('Failed to restore model:', e);
          alert(`‚ö†Ô∏è Model restore failed: ${e.message}`);
        }
      };


      console.log('‚úì All button handlers attached successfully');

      // Verify Start button exists
      const btn = q('btnStartFull');
      if (!btn) {
        console.error('ERROR: Start button not found! ID: btnStartFull');
      } else {
        console.log('‚úì Start button found and handler attached');
      }

      // Start the update intervals (camera every 100ms, data every 1000ms)
      setInterval(updateCamera, 100);
      setInterval(update, 1000);

      // Run initial update immediately
      update();

      console.log('‚úì Update loops started');
    }

    // Make sure DOM is loaded before initializing
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializePage);
    } else {
      initializePage();
    }
  </script>
</body>
</html>
